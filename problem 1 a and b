a 110 (>= 150)
b 26 (< 10)
c 55 (> 100)

0: a 2 b 1 : a -2 b -1 c 4 : 1.0000 : 0 1 2
1: a 1 c 2 : a -1 c -2 b 3 : 2.0000 : 0 1 2
2: b 1 c 1 : b -1 c -1 a 2 : 3.0000 : 0 1 2




//AI generated python code done in colab 


import numpy as np
import matplotlib.pyplot as plt
import random

# ============================================================
# Reaction definitions (based on one-step probabilities from [3,3,3])
# Reactions:
#   R1: 2X1 + X2 -> 4X3    rate = 1
#   R2: X1 + 2X3 -> 3X2    rate = 2
#   R3: X2 + X3  -> 2X1    rate = 9
# Propensity = rate * (product of reactant counts, each to the power of its stoichiometry)
# ============================================================

def propensity(state, rxn):
    x1, x2, x3 = state
    if rxn == 0:      # 2X1 + X2 -> 4X3
        return 1.0 * (x1*(x1-1)//2) * x2   # integer division, but use float
    elif rxn == 1:    # X1 + 2X3 -> 3X2
        return 2.0 * x1 * (x3*(x3-1)//2)
    else:             # X2 + X3 -> 2X1
        return 3.0 * x2 * x3

def gillespie_step(state):
    """Perform one Gillespie step: return new state and a flag (1 if step happened)."""
    props = [propensity(state, i) for i in range(3)]
    total_prop = sum(props)
    if total_prop == 0:
        return state, 0          # no reaction possible
    # Choose reaction
    r = random.random() * total_prop
    cum = 0.0
    for i, p in enumerate(props):
        cum += p
        if r < cum:
            rxn = i
            break
    # Update state according to the chosen reaction
    delta = [0, 0, 0]
    if rxn == 0:          # R1: 2X1 + X2 -> 4X3
        delta[0] = -2
        delta[1] = -1
        delta[2] = +4
    elif rxn == 1:        # R2: X1 + 2X3 -> 3X2
        delta[0] = -1
        delta[1] = +3
        delta[2] = -2
    else:                 # R3: X2 + X3 -> 2X1
        delta[0] = +2
        delta[1] = -1
        delta[2] = -1
    new_state = [state[0] + delta[0],
                 state[1] + delta[1],
                 state[2] + delta[2]]
    return new_state, 1

# ============================================================
# Part (a): Estimate Pr(C1), Pr(C2), Pr(C3) from [110,26,55]
# ============================================================
def part_a(num_trials=10000, max_steps=100000):
    print("Part (a) – Estimating probabilities of conditions")
    count_c1 = 0
    count_c2 = 0
    count_c3 = 0
    for _ in range(num_trials):
        state = [110, 26, 55]
        steps = 0
        hit_c1 = hit_c2 = hit_c3 = False
        while steps < max_steps:
            state, step = gillespie_step(state)
            if step == 0:
                break
            steps += 1
            if state[0] >= 150:
                hit_c1 = True
            if state[1] < 10:
                hit_c2 = True
            if state[2] > 100:
                hit_c3 = True
        if hit_c1:
            count_c1 += 1
        if hit_c2:
            count_c2 += 1
        if hit_c3:
            count_c3 += 1
    print(f"Pr(C1) = {count_c1/num_trials:.4f}")
    print(f"Pr(C2) = {count_c2/num_trials:.4f}")
    print(f"Pr(C3) = {count_c3/num_trials:.4f}")
    return

# ============================================================
# Part (b): Mean, variance, and distributions after 7 steps from [9,8,7]
# ============================================================
def part_b(num_trials=100000):
    print("\nPart (b) – Statistics after 7 steps from [9,8,7]")
    results = {0: [], 1: [], 2: []}   # X1, X2, X3
    for _ in range(num_trials):
        state = [9, 8, 7]
        for step in range(7):
            state, _ = gillespie_step(state)
        for i in range(3):
            results[i].append(state[i])
    # Compute mean and variance
    means = {}
    variances = {}
    for i in range(3):
        means[i] = np.mean(results[i])
        variances[i] = np.var(results[i], ddof=1)
    print(f"X1: mean = {means[0]:.4f}, variance = {variances[0]:.4f}")
    print(f"X2: mean = {means[1]:.4f}, variance = {variances[1]:.4f}")
    print(f"X3: mean = {means[2]:.4f}, variance = {variances[2]:.4f}")

    # Plot histograms
    fig, axes = plt.subplots(1, 3, figsize=(15, 4))
    titles = ['X1 after 7 steps', 'X2 after 7 steps', 'X3 after 7 steps']
    for i, ax in enumerate(axes):
        ax.hist(results[i], bins=30, density=True, alpha=0.7, color='skyblue', edgecolor='black')
        ax.set_title(titles[i])
        ax.set_xlabel('Count')
        ax.set_ylabel('Frequency')
    plt.tight_layout()
    plt.show()
    return

# ============================================================
# Run both parts (set smaller num_trials for quick testing)
# ============================================================
if __name__ == "__main__":
    # For accurate results, use more trials (e.g., 10000 and 100000)
    # Here we use smaller numbers to run quickly – adjust as needed.
    part_a(num_trials=5000, max_steps=50000)
    part_b(num_trials=20000)
